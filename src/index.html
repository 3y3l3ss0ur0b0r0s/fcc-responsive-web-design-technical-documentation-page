..<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="style.css">
  <title id="title">Sorting Algorithms in Python</title>

  <style></style>

</head>

<body>
  <nav id="navbar">
    <header>Sorting Algorithms in Python</header>
    <ul>
      <li><a class="nav-link" href="#bubble_sort">Bubble Sort</a></li>
      <li><a class="nav-link" href="#selection_sort">Selection Sort</a></li>
      <li><a class="nav-link" href="#insertion_sort">Insertion Sort</a></li>
      <li><a class="nav-link" href="#heap_sort">Heap Sort</a></li>
      <li><a class="nav-link" href="#quick_sort">Quick Sort</a></li>
      <li><a class="nav-link" href="#merge_sort">Merge Sort</a></li>
    </ul>
  </nav>
  <main id="main-doc">
    <h1>Sorting Algorithms in Python</h1>
    <section id="bubble_sort" class="main-section">
      <header id="bubble_sort">
        <h2>Bubble Sort</h2>
      </header>
      <h3>Complexity</h3>
      <p>Time complexity:
      <ul>
        <li>Worst case: O(n2)</li>
        <li>Average case: O(n2)</li>
        <li>Best case: (On)</li>
      </ul>
      Space complexity:
      <ul>
        <li>O(1) - Apart from the input array, a constant amount of additional memory is used.</li>
      </ul>
      </p>
      <h3>Summary</h3>
      <p>The highest value (assuming we are sorting in ascending order) element "bubbles up" to the top (left).</p>
      <h3>Implementation</h3>
      <ul>
        <li>We iterate through the array. Each adjacent pair of elements is compared.</li>
        <li>If the adjacent elements are not in the correct order, swap them.</li>
        <li>Repeat step 2 until no more swaps are needed (i.e., all elements are sorted).</li>
      </ul>
      <code>
        def bubbleSort(array):
          n=len(array)
        
          for i in range(n):
            alreadySorted=True
        
          for j in range(n-i-1):
            if array[j]>array[j+1]:
              array[j],array[j+1]=array[j+1],array[j]
              alreadySorted=False
        
          if alreadySorted:
            break
        
          return array
      </code>
    </section>
    <section id="selection_sort" class="main-section">
      <header id="selection_sort">
        <h2>Selection Sort</h2>
      </header>
      <h3>Complexity</h3>
      <p>Time complexity:
      <ul>
        <li>Worst case = Average case = Best case: (On2)</li>
      </ul>
      Space complexity:
      <ul>
        <li>O(1) - Apart from the input array, a constant amount of additional memory is used.</l>
      </ul>
      </p>
      <h3>Summary</h3>
      <p>Selection sort works by dividing the array into two parts: a sorted subarray and a subarray of remaining elements to be sorted. Then, it SELECTS the minimum of the subarray of remaining elements and adds it to the sorted subarray in order.</p>
      <h3>Implementation</h3>
      <ol>
        <li>We assume the first element (i) is the minimum value in the array. Then, iterate over each element in the unsorted subarray (i++).</li>
        <li>For each element (i), go through the remaining subarray (j=i+1 to last element) to look for a new minimum.</li>
        <li>If a new minimum is found, SELECT it and place it in the correct position in the sorted subarray (0 to i).</li>
      </ol>
      <code>
        def selectionSort(array,size):
          
          for ind in range(size):
            minIndex=ind
        
            for j in range(ind+1,size):
              if array[min_index]>array[j]:
                minIndex=j
          
            (array[ind],array[minIndex])=(array[minIndex],array[ind])
            
            return array
      </code>
      </ul>
    </section>
    <section id="insertion_sort" class="main-section">
      <header id="insertion_sort">
        <h2>Insertion Sort</h2>
      </header>
      <h3>Complexity</h3>
      <p>Time complexity:
      <ul>
        <li>Worst case: O(n2)</li>
        <li>Average case: O(n2)</li>
        <li>Best case: (On)</li>
      </ul>
      Space complexity:
      <ul>
        <li>O(1) - Apart from the input array, a constant amount of additional memory is used.</li>
      </ul>
      </p>
      <h3>Summary</h3>
      <p>Insertion sort works by dividing the array into two parts: a sorted subarray and a subarray of remaining elements to be sorted. Then, it iterates over the subarray of remaining elements and INSERTS each element to the sorted subarray in the correct order.</p>
      <h3>Implementation</h3>
      <ol>
        <li>We assume the first element (i) is the minimum value in the array. Then, iterate over each element in the unsorted subarray (i++).</li>
        <li>For each element in the unsorted subarray, we go backwards in the sorted subarray until we find its correct position.</li>
        <li>When the correct position for the unsorted element is found, we INSERT it into the sorted subarray.</li>
      </ol>
      <code>
        def insertionSort(array):
          for i in range(1,len(array)):
            keyItem=array[i]
        
            j=i-1
        
            while j>=0 and array[j] > keyItem:
              array[j+1]=array[j]
              j-=1
        
            array[j+1]=keyItem
        return array
      </code>
    <h3>Additional Notes</h3>
      <ul>
        <li>The difference between insertion sort and selection sort is that, in an insertion sort, we do not look for the smallest element in the unsorted subarray. We just go to each element in the unsorted subarray and put INSERT it into the correct place in the sorted subarray.</li>
      </ul>
    </section>
    <section id="heap_sort" class="main-section">
      <header id="heap_sort">
        <h2>Heap Sort</h2>
      </header>
      <p>Time complexity:
      <ul>
        <li>Worst case = Average case = Best case: O(n log n)</li>
      </ul>
      Space complexity:
      <ul>
        <li>O(1) - Heap sort is an in-place sorting algorithm.</li>
      </ul>
      </p>
      <h3>Summary</h3>
      <p>In heap sort, the array is converted into a heap. Then, we extract the maximum element from the heap and place it accordingly. Heap sort reconstructs the heap after each extraction.
      </p>
      <h3>Implementation</h3>
      <ol>
        <li>Convert the array into a heap data structure.</li>
        <li>Get the maximum element from the heap and place it at the end of the array.</li>
        <li>Reconstruct the heap.</li>
      </ol>
      <code>
        def convertToHeap(array,n,i):
          largest=i
          l=2*i+1
          r=2*i+2
        
          if n>l and array[l]>array[i]:
            largest=1

          if n>r and array[r]>array[largest]
            largest=r

          if largest!=i:
            (array[i],array[largest])=(array[largest],array[i])
        
          convertToHeap(array,n,largest)
        
        def heapSort(array):
          n=len(array)
        
          for i in range(n//2-1,-1,-1):
            convertToHeap(array,n,i)
        
          for i in range(n-1,0,-1):
            (array[i],array[0])=(array[0],array[i])
            convertToHeap(array,i,0)
      </code>
      <h3>Additional Notes</h3>
      <ul>
        <li>Heap sort is similar to selection sort, except we are finding the maximum element (instead of the minimum element) and placing it at the end.</li>
      </ul>
    </section>
    <section id="quick_sort" class="main-section">
      <header id="quick_sort">
        <h2>Quick Sort</h2>
      </header>
      <p>Time complexity:
      <ul>
        <li>Worst case: O(n2)</li>
        <li>Average case = Best case: O(n log n)</li>
      </ul>
      Space complexity:
      <ul>
        <li>O(n) - Quick sort requires additional space for creating stack frames in recursve calls.</li>
      </ul>
      </p>
      <h3>Summary</h3>
      <p>Quick sort uses a divide-and-conquer strategy, dividing an array into subarrays based on a chosen "pivot" element. First, we choose an element called "pivot" and divide the array into two subarrays. We place pivot in its correct index, and then reorder the array by moving all the elements less than pivot to its left and all the elements greater than it to its right.
        <br><br>
        Then, we recursively sort the subarrays of these subarrays until the entire array is sorted. Quick sort's efficiency depends on the selection of the pivot element.
      </p>
      <h3>Implementation</h3>
      <ol>
        <li>First, we pick an element ("pivot").</li>
        <li>Then, we split the array into two subarrays on either side of the pivot. The smaller elements go into a subarray on one side, and the larger ones go into a different subarray on the other side.</li>
        <li>Steps 1 and 2 are repeated within the subarrays.</li>
        <li>Once the subarrays are sorted, they are combined into the complete array.</li>
      </ol>
      <code>
        from random import randint
        
        def quickSort(array):
          
          if 2>len(array):
            return array
          
          low,same,high=[],[],[]
        
          pivot=array[randint(0,len(array)-1)]
        
          for item in array:
            if pivot>item:
              low.append(item)
            elif item==pivot:
              same.append(item)
            elif item>pivot:
              high.append(item)
        
          return quickSort(low)+same+quickSort(high)
      </code>
      <h3>Additional Notes</h3>
      <ul>
        <li>Implementation of quick sort is recursive.</li>
        <li>For the best case scenario, choose the median element; that way the array is partitioned such that it can be divided in half every time.</li>
        <li>To avoid the worst-case scenario, choose an good pivot point by doing one of the below:</li>
        <ol>
          <li>Choose the pivot from the middle of the array</li>
          <li>Adopt a random selection of pivots</li>
          <li>Take the medion of 3 pivot candidates (i.e., the median of the first, middle, and last elements of the array)</li>
        </ol>
      </ul>
    </section>
    <section id="merge_sort" class="main-section">
      <header id="merge_sort">
        <h2>Merge Sort</h2>
      </header>
      <h3>Complexity</h3>
      <p>Time complexity:
      <ul>
        <li>Worst case = Average case = Best case: O(n log n)</li>
      </ul>
      Space complexity:
      <ul>
        <li>O(n) - An auxiliary array is used to store the merged subarray.</li>
      </ul>
      </p>
      <h3>Implementation</h3>
      <ol>
        <li>Divide the unsorted array into n subarrays, each with one element.</li>
        <li>Repeatedly merge the sorted subarrays to produce new sorted subarrays until there is only one n-sized array.</li>
      </ol>
      <code>
        def merge(array,l,m,r):
          n1=m-l+1
          n2=r-m
        
          L=[0]*(n1)
          R=[0]*(n2)
        
          for i in range(0,n1):
            L(i)=array[l+i]
        
          for j in range(0,n2):
            R[j]=array[m+1+j]
        
          i=0
          j=0
          k=l
        
          while n1>i and n2>j:
            if R[j] >= L[i]:
              array[k]=L[i]
              i+=1
            else:
              array[k]=R[j]
              j+=1
            k+=1
        
          while n1>i:
            array[k]=L[i]
            i+=1
            k+=1
        
          while n2>j:
            arr[k]=R[j]
            j+=1
            k+=1
        
        def mergeSort(array,l,r):
          if r>l:
            m=l+(r-l)//2
        
            mergeSort(arr,l,m)
            mergeSort(arr,m+1,r)
            merge(arr,l,m,r)
      </code>
    </section>
  </main>
  <footer>Copyright © 3y3l3ss0ur0b0r0s 2022</footer>
  <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</body>

</html>